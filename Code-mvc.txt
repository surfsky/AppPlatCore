--------------------------------------------------------
RazorPage
https://learn.microsoft.com/zh-cn/aspnet/core/razor-pages/?view=aspnetcore-7.0&tabs=visual-studio
--------------------------------------------------------
几个易错点先记下（供回顾）
    model中的属性只在第一次绑定时有效，Post回来后再次对属性赋值是不会影响到客户端的。
    post 处理要想影响到客户端，可以使用以下方法将脚本传递到客户端去执行：
        FineUICore.PageContext.RegistStartupScript();
        UIHelper.Grid("xxx").SomeAction();
        其实方法二就是对方法一的封装，FineUI对控件的Ajax支持并不全面，可考虑用方法一或自行封装Helper。
    尽量别用ViewData，而是用模型的属性。
        ViewData 是老的 mvc 方式传递参数的方法，是弱类型的，编译不报错。
        AppBoxCore RazorPage 引入 ViewData 只是为了兼容老的 mvc 代码，可以考虑删除。
    如何将客户端参数带到服务器端
        根本上都是构造请求字符串
        FineUI的话，设置 fields=“grid1”就可以了，会将参数带到服务器端


初始化
    builder.Services.AddRazorPages();
    builder.Services.AddRazorPages(options =>
    {
        options.RootDirectory = "/MyPages";
        options.Conventions.AuthorizeFolder("/MyPages/Admin");
    });

指令
    @page
    @namespace RazorPagesIntro.Pages.Customers
    @model NameSpaceModel
    @namespace RazorPagesContacts.Pages
    @addTagHelper *, Microsoft.AspNetCore.Mvc.TagHelpers


Helper
    @Url.Handler("SignOutClick")
        http://localhost:52221/Test/Buttons?handler=SignOutClick
    @Url.Action("SignOut")
        http://localhost:52221/Test/Buttons?action=SignOut
    @Url.Content
        IconUrl="@Url.Content("~/res/images/my_face_80.jpg")"
    @Html.DisplayNameFor
        @Html.DisplayNameFor(model => model.Student.LastName)

Page demo
    @page
    @model ContosoUniversity.Pages.Students.DeleteModel
    @{ViewData["Title"] = "Delete";}
    <h1>Delete</h1>
    <p class="text-danger">@Model.ErrorMessage</p>
    <h3>Are you sure you want to delete this?</h3>
    <div>
        <h4>Student</h4>
        <dl class="row">
            <dt class="col-sm-2">@Html.DisplayNameFor(model => model.Student.LastName)</dt>
            <dd class="col-sm-10">@Html.DisplayFor(model => model.Student.LastName)</dd>
            <dt class="col-sm-2">@Html.DisplayNameFor(model => model.Student.FirstMidName)</dt>
            <dd class="col-sm-10">@Html.DisplayFor(model => model.Student.FirstMidName)</dd>
            <dt class="col-sm-2">@Html.DisplayNameFor(model => model.Student.EnrollmentDate)</dt>
            <dd class="col-sm-10">@Html.DisplayFor(model => model.Student.EnrollmentDate)</dd>
        </dl>
        <form method="post">
            <input type="hidden" asp-for="Student.ID" />
            <input type="submit" value="Delete" class="btn btn-danger" /> |
            <a asp-page="./Index">Back to List</a>
        </form>
    </div>

Page dbcontext
    public class EditModel : PageModel
    {
        private readonly AppDbContext _db;
        public EditModel(AppDbContext db)
        {
            _db = db;
        }
    }


OnGet/OnGetAsync
    public IActionResult OnGet()
    {
        ViewBag.btnClientClick2Script = Alert.GetShowInTopReference("通过ViewBag传递的客户端事件");
        var action = Asp.GetQueryString("action");
        if (action == "SignOut")
            return RedirectToPage("/Login");
        return UIHelper.Result();
    }
    public async Task<IActionResult> OnGetAsync(int? id)
    {
        if (id == null)
            return NotFound();
        Student = await _context.Students.FindAsync(id);
        if (Student == null)
            return NotFound();
        return Page();
    }

OnPost/OnPostAsync
    默认
        // Student/Edit/98
        public async Task<IActionResult> OnPostAsync()
        {
            if (!ModelState.IsValid)
                return Page();
            if (Student != null) 
                _context.Students.Add(Student);
            await _context.SaveChangesAsync();
            return RedirectToPage("./Index");
        }
    删除
        // Students?id=1&handler=delete
        public async Task<IActionResult> OnPostDeleteAsync(int id)
    其它结构
        // 处理方法名结构如：OnPost[handler]Async
        <input type="submit" asp-page-handler="JoinList" value="Join" />
        <input type="submit" asp-page-handler="JoinListUC" value="JOIN UC" />
        public async Task<IActionResult> OnPostJoinListAsync()
        public async Task<IActionResult> OnPostJoinListUCAsync()


Web资源隔离
    将 CSS 样式隔离到各个页面、视图和组件以减少或避免：发布应用后，框架会自动将资源移动到 wwwroot 目录
    https://learn.microsoft.com/zh-cn/aspnet/core/razor-pages/?view=aspnetcore-6.0&tabs=visual-studio
    Pages/Index.cshtml.css
    Pages/Index.cshtml.js
    Index.razor.js
    @section Scripts {
      <script src="~/Pages/Index.cshtml.js"></script>
    }

CSS 预处理
    AspNetCore.SassCompiler）可以在生成过程开始时编译 SASS/SCSS 文件

Layout
    Shared/_Layout.cshtml
        @RenderSection("head", false)
        @RenderSection("body", true)
        @RenderSection("script", false)
    Page
        @{Layout = "_Layout";}
        @{Layout = null;}
        @section head {...}
        @section body {...}
        @section script {...}



页面跳转
    RedirectToPage


ViewData
    ViewData 是一个对象数组，对应的有 RazorPageBase.ViewBag，感觉是过度设计了
    [ViewData]
    public string Title { get; } = "About";
    <h1>@Model.Title</h1>
    <title>@ViewData["Title"]</title>


RazorPageFilter
    Razor 页面筛选器提供的以下方法可在全局或页面级应用。类似以前的HttpModule。
    同步方法：
        OnPageHandlerSelected：在选择处理程序方法后，但在模型绑定发生之前调用。
        OnPageHandlerExecuting：在模型绑定完成后，执行处理程序方法之前调用。
        OnPageHandlerExecuted：在执行处理器方法后，生成操作结果前调用。
    异步方法：
        OnPageHandlerSelectionAsync：在选择处理程序方法后，但在模型绑定发生前，进行异步调用。
        OnPageHandlerExecutionAsync：在调用处理程序方法前，但在模型绑定结束后，进行异步调用。

    services.AddRazorPages(options =>
    {
        options.Conventions.AddFolderApplicationModelConvention(
            "/Movies",
            model => model.Filters.Add(new SampleAsyncPageFilter(Configuration)));
    });


PageModel.Result
    success
        ContentResult
        FileStreamResult
        FileContentResult
        PageResult
        PartialViewResult
        PhysicalFileResult
    fail
        BadRequestObjectResult
        BadRequestResult
        ForbidResult
        ChallengeResult
        VirtualFileResult
        NotFoundResult
        NotFoundObjectResult
    route
        RedirectResult
        RedirectToActionResult
        RedirectToPageResult
        RedirectToRouteResult
        LocalRedirectResult
    auth
        SignInResult
        SignOutResult
        UnauthorizedResult
    other
        StatusCodeResult
        ObjectResult
        ViewComponentResult

--------------------------------------------------------
Razor page data binding
--------------------------------------------------------
页面数据模型、绑定属性
    https://learn.microsoft.com/zh-cn/aspnet/core/data/ef-rp/crud?view=aspnetcore-6.0#overposting
    [BindProperty]
    public Student? Student { get; set; }
    public async Task<IActionResult> OnPostAsync()
    {
        if (!ModelState.IsValid)
            return Page();
        if (Student != null) 
            _context.Students.Add(Student);
        await _context.SaveChangesAsync();
        return RedirectToPage("./Index");
    }
    <input asp-for="Customer!.Name" />
    使用绑定属性，可以在前台和后台自动传递类对象，简化字段的收集组装工作
    对于一些简单类型的字段，用绑定属性可以大大简化数据采集验证代码

绑定属性过度发布的处理
    https://learn.microsoft.com/zh-cn/aspnet/core/data/ef-rp/crud?view=aspnetcore-6.0#overposting
    若页面端不需要填写所有字段，使用 BindProperty 会有两个潜在的问题
        （1）占用带宽。对简单类问题不大，对于复杂类型需要考证。
        （2）黑客会Post非需要字段，导致数据被篡改。
        public class Student
        {
            public int ID { get; set; }
            public string LastName { get; set; }
            public string FirstMidName { get; set; }
            public DateTime EnrollmentDate { get; set; }
            public string Secret { get; set; }            // 隐私字段
        }
    解决方案
        （1）把需要修改的字段剥离出来，作为PageModel的属性。
        （2）创建PageModel，只包含需要修改的字段。如：
        public class StudentVM
        {
            public int ID { get; set; }
            public string LastName { get; set; }
            public string FirstMidName { get; set; }
            public DateTime EnrollmentDate { get; set; }
        }

数据获取和更新
    public async Task<IActionResult> OnGetAsync(int? id)
    {
        if (id == null)
            return NotFound();
        Student = await _context.Students.FindAsync(id);
        if (Student == null)
            return NotFound();
        return Page();
    }
    public async Task<IActionResult> OnPostAsync(int id)
    {
        var studentToUpdate = await _context.Students.FindAsync(id);
        if (studentToUpdate == null)
            return NotFound();

        if (await TryUpdateModelAsync<Student>(
            studentToUpdate,
            "student",
            s => s.FirstMidName, s => s.LastName, s => s.EnrollmentDate))
        {
            await _context.SaveChangesAsync();
            return RedirectToPage("./Index");
        }

        return Page();
    }

--------------------------------------------------------
EF
--------------------------------------------------------
实体类变更迁移
    https://learn.microsoft.com/zh-cn/ef/core/managing-schemas/migrations/?tabs=dotnet-core-cli
        services.AddDbContext<AppPlatContext>(options => {
            options.UseSqlite(sqlite, builder => builder.MigrationsAssembly("App"));
        });
        dotnet ef migrations add InitialCreate
        dotnet ef migrations add UseEntityBase
        dotnet ef database update
        dotnet ef migrations remove
    创建迁移时报错
        Unable to create an object of type 'EFDbContext'. Add an implementation of 'IDesignTimeDbContextFactory<EFDbContext>' to the project, or see https://go.microsoft.com/fwlink/?linkid=851728 for additional patterns supported at design time.
        https://blog.csdn.net/weixin_34187822/article/details/94630370
        Dbcontext没有在Web项目里面，所以他找不到链接字符串，没办法实例化DbContext
        解决方案：我们在Dbcontext的同级目录新建一个类DesignTimeDbContextFactory
        让这个类继承IDesignTimeDbContextFactory接口
    执行迁移时报错
    重建数据库
        dotnet ef database drop
        dotnet ef migrations add InitialCreate
        dotnet ef database update

        

数据验证
    实体对象
        using System.ComponentModel.DataAnnotations;
        public class Movie
        {
            public int ID { get; set; }

            [StringLength(60, MinimumLength = 3)]
            [Required]
            public string Title { get; set; }

            [Display(Name = "Release Date")]
            [DataType(DataType.Date)]
            public DateTime ReleaseDate { get; set; }

            [Range(1, 100)]
            [DataType(DataType.Currency)]
            [Column(TypeName = "decimal(18, 2)")]
            public decimal Price { get; set; }

            [RegularExpression(@"^[A-Z]+[a-zA-Z\s]*$")]
            [Required]
            [StringLength(30)]
            public string Genre { get; set; }

            [RegularExpression(@"^[A-Z]+[a-zA-Z0-9""'\s-]*$")]
            [StringLength(5)]
            [Required]
            public string Rating { get; set; }
        }
    客户端校验
        @page
        @model CreateFATHModel
        <html>
        <body>
            <p>Enter your name.</p>
            <div asp-validation-summary="All"></div>
            <form method="POST">
                <div>Name: <input asp-for="Customer.Name" /></div>
                <input type="submit" asp-page-handler="JoinList" value="Join" />
                <input type="submit" asp-page-handler="JoinListUC" value="JOIN UC" />
            </form>
        </body>
        </html>
    服务器端校验
        if (!ModelState.IsValid)
            return Page();
 
#--------------------------------------------
# Page Filter
#--------------------------------------------
Razor 页面筛选器：
    类似 HttpModule 的东东
    https://learn.microsoft.com/zh-cn/aspnet/core/razor-pages/filter?view=aspnetcore-7.0
    - 在选择处理程序方法后但在模型绑定发生前运行代码。
    - 在模型绑定完成后，执行处理程序方法前运行代码。
    - 在执行处理程序方法后运行代码。
    - 可在页面或全局范围内实现。
    - 可以用依赖项注入 (DI) 填充构造函数依赖项。 有关详细信息，请参阅 ServiceFilterAttribute 和 TypeFilterAttribute。
同步方法：
    OnPageHandlerSelected：在选择处理程序方法后，但在模型绑定发生之前调用。
    OnPageHandlerExecuting：在模型绑定完成后，执行处理程序方法之前调用。
    OnPageHandlerExecuted：在执行处理器方法后，生成操作结果前调用。
异步方法：
    OnPageHandlerSelectionAsync：在选择处理程序方法后，但在模型绑定发生前，进行异步调用。
    OnPageHandlerExecutionAsync：在调用处理程序方法前，但在模型绑定结束后，进行异步调用。


ResultFilterAttribute
    简化Filter，用Attribute提供服务
    using System.Threading.Tasks;
    using Microsoft.AspNetCore.Mvc.Filters;
    namespace PageFilter.Filters
    {
        public class AddHeaderAttribute  : ResultFilterAttribute
        {
            private readonly string _name;
            private readonly string _value;

            public AddHeaderAttribute (string name, string value)
            {
                _name = name;
                _value = value;
            }

            public override void OnResultExecuting(ResultExecutingContext context)
            {
                context.HttpContext.Response.Headers.Add(_name, new string[] { _value });
            }
        }
    }
    [AddHeader("Author", "Rick")]
    public class TestModel : PageModel
    [Authorize]
    public class ModelWithAuthFilterModel : PageModel

#--------------------------------------------
# Aspnetcore mvc 演变
#--------------------------------------------
最简示例，开启网站，显示 hello world
    Host.CreateDefaultBuilder()
        .ConfigureWebHost(webHostBuilder => webHostBuilder
            .UseKestrel()
            .UseUrls("http://0.0.0.0:3721;https://0.0.0.0:9527")
            .Configure(app => app.Run(context => context.Response.WriteAsync("Hello World."))))
        .Build()
        .Run()
        ;

配置服务、中间件、MVC
    Host.CreateDefaultBuilder()
        .ConfigureWebHostDefaults(webHostBuilder => webHostBuilder
            .ConfigureServices(servicecs => servicecs
                .AddRouting()
                .AddControllersWithViews())
            .Configure(app => app
                .UseRouting()
                .UseEndpoints(endpoints => endpoints.MapControllers())))
        .Build()
        .Run()
        ;
    public class HelloController
    {
        [HttpGet("/hello")]
        public string SayHello() => "Hello World";
    }

将配置写到单独的类
    Host.CreateDefaultBuilder()
        .ConfigureWebHostDefaults(webHostBuilder => webHostBuilder.UseStartup<Startup>())
        .Build()
        .Run()
        ;
    public class Startup
    {
        public void ConfigureServices(IServiceCollection services) => services
            .AddRouting()
            .AddControllersWithViews()
        ;
        public void Configure(IApplicationBuilder app) => app
            .UseRouting()
            .UseEndpoints(endpoints => endpoints.MapControllers())
        ;
    }


拆分控制器和视图
    ``` 
    public class HelloController : Controller
    {
        [HttpGet("/hello/{name}")]
        public IActionResult SayHello(string name)
        {
            ViewBag.Name = name;
            return View();  // 会去找 /views/hello/SayHello.cshtml
        }
    }
    /views/hello/SayHello.cshtml
    <html>
    <head>
        <title>Hello World</title>
    </head>
    <body>
        <p>Hello, @ViewBag.Name</p>
    </body>
    </html>
    ```


